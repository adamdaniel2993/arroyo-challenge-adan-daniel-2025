name: Deploy (Backend interactivo → Terraform → Build & Push)

on:
  push:
    branches: [ main ]
    paths:
      - '*.tf'
      - 'docker_image/**'
      - '.github/workflows/challengeTerraform.yaml'

  workflow_dispatch:
    inputs:
      aws_region:
        description: AWS region
        default: us-east-1
        required: true
      tf_state_bucket:
        description: 'Nombre del S3 para el state (se creará si no existe)'
        required: true
      tf_lock_table:
        description: 'Tabla DynamoDB para locks'
        default: terraform-state-locks
        required: true
      tf_state_key:
        description: 'Key del state en S3'
        default: arroyo-challenge/terraform.tfstate
        required: true
      ecr_repo_name:
        description: 'Nombre del repo ECR que crea Terraform'
        default: arroyo-ecr
        required: true
      docker_context:
        description: 'Carpeta del Dockerfile'
        default: docker_image
        required: true
      dockerfile:
        description: 'Nombre del Dockerfile'
        default: Dockerfile
        required: true

env:
  IMAGE_TAG: ${{ github.sha }}

jobs:
  apply:
    runs-on: ubuntu-latest
    outputs:
      ecr_uri: ${{ steps.tfout.outputs.ecr_uri }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ inputs.aws_region != '' && inputs.aws_region || vars.AWS_REGION != '' && vars.AWS_REGION || 'us-east-1' }}

      # Bootstrap backend S3+DynamoDB (idempotente)
      - name: Ensure backend (S3 + DynamoDB)
        shell: bash
        run: |
          set -euo pipefail
          BUCKET="${{ inputs.tf_state_bucket }}"
          TABLE="${{ inputs.tf_lock_table }}"
          REGION="${{ inputs.aws_region }}"

          if aws s3api head-bucket --bucket "$BUCKET" 2>/dev/null; then
            echo "Bucket $BUCKET exists."
          else
            if [ "$REGION" = "us-east-1" ]; then
              aws s3api create-bucket --bucket "$BUCKET"
            else
              aws s3api create-bucket --bucket "$BUCKET" \
                --create-bucket-configuration LocationConstraint="$REGION"
            fi
            aws s3api put-bucket-versioning --bucket "$BUCKET" --versioning-configuration Status=Enabled
            aws s3api put-bucket-encryption --bucket "$BUCKET" --server-side-encryption-configuration \
              '{"Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}'
            aws s3api put-public-access-block --bucket "$BUCKET" --public-access-block-configuration \
              '{"BlockPublicAcls":true,"IgnorePublicAcls":true,"BlockPublicPolicy":true,"RestrictPublicBuckets":true}'
          fi

          if aws dynamodb describe-table --table-name "$TABLE" >/dev/null 2>&1; then
            echo "DynamoDB $TABLE exists."
          else
            aws dynamodb create-table \
              --table-name "$TABLE" \
              --billing-mode PAY_PER_REQUEST \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH
            aws dynamodb wait table-exists --table-name "$TABLE"
          fi

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Init (remote backend)
        run: |
          terraform init \
            -backend-config="bucket=${{ inputs.tf_state_bucket }}" \
            -backend-config="key=${{ inputs.tf_state_key }}" \
            -backend-config="region=${{ inputs.aws_region }}" \
            -backend-config="dynamodb_table=${{ inputs.tf_lock_table }}" \
            -backend-config="encrypt=true"

      - name: Terraform fmt & validate
        run: |
          terraform fmt -check
          terraform validate

      - name: Terraform Apply
        run: terraform apply -auto-approve

      - name: Capture ECR URI from Terraform outputs
        id: tfout
        shell: bash
        run: |
          # Requiere output "ecr_repository_url"
          if terraform output -raw ecr_repository_url >/dev/null 2>&1; then
            ECR_URI=$(terraform output -raw ecr_repository_url)
          else
            NAME="${{ inputs.ecr_repo_name }}"
            set +e
            ECR_URI=$(aws ecr describe-repositories --repository-names "$NAME" \
              --query 'repositories[0].repositoryUri' --output text 2>/dev/null)
            if [ -z "$ECR_URI" ] || [ "$ECR_URI" = "None" ]; then
              ECR_URI=$(aws ecr-public describe-repositories --repository-names "$NAME" --region ${{ inputs.aws_region }} \
                --query 'repositories[0].repositoryUri' --output text 2>/dev/null)
            fi
            set -e
          fi
          echo "ecr_uri=$ECR_URI" >> "$GITHUB_OUTPUT"
          echo "ECR_URI=$ECR_URI"

  build_and_push:
    runs-on: ubuntu-latest
    needs: apply
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ inputs.aws_region }}

      - name: Login to ECR (private/public)
        shell: bash
        env:
          ECR_URI: ${{ needs.apply.outputs.ecr_uri }}
        run: |
          set -euo pipefail
          if [[ "$ECR_URI" == public.ecr.aws/* ]]; then
            aws ecr-public get-login-password --region ${{ inputs.aws_region }} \
              | docker login --username AWS --password-stdin public.ecr.aws
          else
            REG_HOST="${ECR_URI%%/*}"
            aws ecr get-login-password --region ${{ inputs.aws_region }} \
              | docker login --username AWS --password-stdin "$REG_HOST"
          fi

      - name: Build & Push image (latest + SHA)
        env:
          ECR_URI: ${{ needs.apply.outputs.ecr_uri }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          DOCKER_CONTEXT: ${{ inputs.docker_context }}
          DOCKERFILE: ${{ inputs.dockerfile }}
        run: |
          set -euo pipefail
          SHORT_SHA="${IMAGE_TAG::12}"
          docker build -f "${DOCKER_CONTEXT}/${DOCKERFILE}" \
                       -t "${ECR_URI}:${SHORT_SHA}" \
                       -t "${ECR_URI}:latest" \
                       "${DOCKER_CONTEXT}"
          docker push "${ECR_URI}:${SHORT_SHA}"
          docker push "${ECR_URI}:latest"
